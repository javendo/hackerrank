package cubesummation

object Solution {
  //def size: (Int, Int) => Int = (n, acc) => if (n > 1) size(n >> 1, acc + 1) else acc
  //def secondComplement: Int => Int = n => ((1 << size(n, 1)) - 1) ^ n
  //def parent: Int => Int = n => n - (secondComplement(n) + 1)
  //def next: Int => Int = n => secondComplement(n) + 1 + n

  def update(arr: Array[Array[Array[Int]]], x: Int, y: Int, z: Int, v: Int) = {
    val size = arr.size
    arr(0)(0)(0) += v
    arr(x)
  }

  def query(arr: Array[Array[Array[Int]]], x1: Int, y1: Int, z1: Int, x2: Int, y2: Int, z2: Int) = {
  }

  def main(args: Array[String]) {
    import java.io.{BufferedReader, BufferedWriter, InputStreamReader, OutputStreamWriter}
    val reader = new BufferedReader(new InputStreamReader(System.in))
    val writer = new BufferedWriter(new OutputStreamWriter(System.out))
    val squares = reader.readLine.toInt
    for (_ <- 1 to squares) {
      val params = reader.readLine.split(" ").map(_.toInt)
      val size = params(0)
      val arr = Array.ofDim(size, size, size)
      val queries = params(1)
      for (_ <- 1 to queries) {
        val qry = reader.readLine.split(" ")
        val qryType = qry(0)
        if (qryType == "UPDATE") update(arr, qry(1).toInt, qry(2).toInt, qry(3).toInt, qry(4).toInt)
        if (qryType == "QUERY") query(arr, qry(1).toInt, qry(2).toInt, qry(3).toInt, qry(4).toInt, qry(5).toInt, qry(6).toInt)
      }
    }
  }

}
